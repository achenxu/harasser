#! /usr/bin/env node

var cli = require('cli')
var async = require('async')
var fs = require('fs')
var request = require('request')
var _ = require('lodash')
var pkg = require('./package.json')
var EXIT_CONDITION = false
cli.enable('help', 'version', 'status')
cli.setApp('harass', pkg.version)
var iterOpts = [ 'i', 'number of iterations', 'number' ]
var bandwidthOpts = [ 'b', 'number of calls to run simultaneously', 'number', '10' ]
var repeatOpts = [ 'r', 'time (ms) between repeating call', 'number', '1000' ]
var methodUrlOpts = [ 'mu', 'append method to url to call', 'boolean', true ]
var headersOpts = [ 'h', 'headers, comma delineated', 'string', 'Host:httpbin.org' ]
// var fixturesOpts = [ 'f', 'include fixtures with appropriate calls, randomly assigned', 'boolean', true ]
var methodOpts = [ 'm', 'methods of HTTP calls to send, comma-delineated', 'string', 'post,get,put,patch,delete' ]
var options = cli.parse({
  iterations: iterOpts,
  bandwidth: bandwidthOpts,
  repeat: repeatOpts,
  methods: methodOpts,
  methodurl: methodUrlOpts,
  headers: headersOpts
  // fixures: fixturesOpts
})
var iterations = 0
cli.main(function (args, options) {
  urlToCall = args[0] || 'http://localhost:8000'
  options.urlToCall = urlToCall
  options.methods = options.methods.split(',')
  options.methods = options.methods.map(function (type) {
    type = type.trim().toLowerCase()
    return type
  })
  if (options.headers.indexOf(',') > -1) {
    options.headers = options.headers.split(',')
  } else {
    options.headers = [options.headers]
  }
  options.headers = _.map(options.headers, function (header) {
    header = header.split(':')
    return {
      name: header[0].trim(),
      value: header[1].trim()
    }
  })
  // process.exit()
  runCalls(options)
})
function sleep (milliseconds) {
  var start = new Date().getTime()
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds) {
      break
    }
  }
}
function runCalls (options) {
  var callsArray = []
  for (var i = 0; i < options.bandwidth; i++) {
    var callFunction = new Promise(function (resolve, reject) {
      var randomIndex = getRandom(0, options.methods.length)
      var randomMethod = options.methods[randomIndex]
      var method = randomMethod.toUpperCase()
      var requestHeaders = {}
      _.forEach(options.headers, function (header) {
        requestHeaders[header.name] = header.value
      })
      var urlToCall = options.urlToCall
      if(options.methodurl){
        urlToCall = options.urlToCall + '/' + randomMethod
      }
      console.log('requesting', method, urlToCall)
      opts = {
        method: method,
        url: urlToCall,
        headers: requestHeaders,
        har: {
          url: urlToCall,
          method: method,
          headers: options.headers,
          postData: {
            mimeType: '',
            params: []
          }
        }
      }
      var bodyAccepted = (method !== 'GET' && method !== 'DELETE' && method !== 'HEAD')
      var fileStream = false
      if (bodyAccepted) {
        var randomNumber = getRandom(0, 8)
        if (randomNumber < 3) {
          opts.headers['X-Filetype'] = 'Form Data'
          opts.har.headers.push({ name: 'X-Filetype', value: 'Form Data' })
          opts.har.postData.mimeType = 'application/x-www-form-urlencoded'
          opts.har.postData.params = [
            {
              name: 'my_field',
              value: 'my_value'
            },
            {
              name: 'my_field1',
              value: 'my_value1'
            },
            {
              name: 'my_field2',
              value: 'my_value2'
            },
            {
              name: 'my_field3',
              value: 'my_value3'
            },
            {
              name: 'my_field4',
              value: 'my_value4'
            }
          ]
        } else {
          fileStream = true
          delete opts.har
        }
      }
      if (bodyAccepted && fileStream) {
        var fileExtensions = ['css', 'csv', 'gif', 'html', 'ico', 'jpg', 'js', 'json', 'md', 'png', 'svg', 'txt', 'xml', 'yml']
        var fileExtension = fileExtensions[getRandom(0, fileExtensions.length - 1)]
        opts.headers['X-Filetype'] = fileExtension
        var file = fs.createReadStream(__dirname + '/fixtures/test.' + fileExtension)
        file.pipe(request(opts))
        var buffer = ''
        file.on('data', function (chunk) {
          buffer += chunk
        })
        file.on('end', function () {
          resolve(buffer)
        })
      } else {
        request(opts, function (err, results) {
          if (err) {
            console.error(err)
            process.exit()
          }
          console.log(method, urlToCall, new Date())
          resolve(results)
        })
      }
    })
    callsArray.push(callFunction)
  }
  Promise.all(callsArray).then(function (results) {
    iterations++
    console.log('finished iteration', iterations)
    sleep(options.repeat)
    if (options.iterations) {
      if (iterations < options.iterations) {
        runCalls(options)
      } else {
        EXIT_CONDITION = true
      }
    } else {
      runCalls(options)
    }
  }).catch(function (error) {
    console.error(error)
    process.exit()
  })
}
function getRandom (min, max) {
  return Math.floor(Math.random() * (max - min) + min)
}
function utf8_to_b64 (str) {
  return new Buffer(str).toString('base64')
}
(function wait () {
  if (!EXIT_CONDITION) setTimeout(wait, 1000)
})()
